#!/usr/bin/env node

/**
 * Test script for the new LLM-based Next Mavens system
 * This script verifies that all responses are generated by the LLM
 * and no hardcoded responses are used.
 */

const { spawn } = require('child_process');
const path = require('path');

console.log('ğŸ§ª Testing Next Mavens LLM-Based System...\n');

// Test configuration
const testCases = [
  {
    name: 'Basic Greeting',
    input: 'Hello',
    expectedKeywords: ['hello', 'greeting', 'welcome', 'help'],
    shouldNotContain: ['I can help with Git operations', 'Try: git status']
  },
  {
    name: 'Git Status Request',
    input: 'Show me git status',
    expectedKeywords: ['git', 'status', 'branch', 'staged', 'unstaged'],
    shouldNotContain: ['I can help with Git operations. Try: git status, commit message, push, or pull']
  },
  {
    name: 'Code Analysis Request',
    input: 'Analyze my code quality',
    expectedKeywords: ['analyze', 'quality', 'code', 'report', 'issues'],
    shouldNotContain: ['I can analyze code quality. Try: analyze code quality or run lint check']
  },
  {
    name: 'Database Connection Request',
    input: 'Connect to supabase',
    expectedKeywords: ['supabase', 'database', 'connect', 'connection'],
    shouldNotContain: ['I can help with database operations. Try: connect to supabase URL or query SQL']
  },
  {
    name: 'MCP Tools Request',
    input: 'List MCP tools',
    expectedKeywords: ['mcp', 'tools', 'servers', 'available'],
    shouldNotContain: ['I can help with MCP operations. Try: list tools or connect server-command']
  },
  {
    name: 'Help Request',
    input: 'What can you do?',
    expectedKeywords: ['help', 'capabilities', 'features', 'assist'],
    shouldNotContain: ['I can help you with:', 'File operations (read, write, create, search)']
  }
];

async function runTest(testCase) {
  return new Promise((resolve, reject) => {
    console.log(`ğŸ“‹ Testing: ${testCase.name}`);
    console.log(`   Input: "${testCase.input}"`);
    
    // Start the CLI process
    const cliProcess = spawn('node', ['packages/cli/dist/index.js'], {
      stdio: ['pipe', 'pipe', 'pipe'],
      cwd: process.cwd()
    });

    let output = '';
    let hasResponded = false;
    let timeout;

    // Set up timeout
    timeout = setTimeout(() => {
      cliProcess.kill();
      reject(new Error(`Test timed out for: ${testCase.name}`));
    }, 30000); // 30 second timeout

    // Handle stdout
    cliProcess.stdout.on('data', (data) => {
      const text = data.toString();
      output += text;
      
      // Check if we got a response (not just loading messages)
      if (text.includes('assistant') || text.includes('Next Mavens') || text.includes('Welcome')) {
        hasResponded = true;
      }
      
      // If we have a substantial response, we can end the test
      if (hasResponded && output.length > 200) {
        clearTimeout(timeout);
        cliProcess.kill();
        
        // Analyze the response
        const analysis = analyzeResponse(output, testCase);
        resolve(analysis);
      }
    });

    // Handle stderr
    cliProcess.stderr.on('data', (data) => {
      console.log(`   Error: ${data.toString()}`);
    });

    // Handle process exit
    cliProcess.on('close', (code) => {
      clearTimeout(timeout);
      if (code !== 0 && !hasResponded) {
        reject(new Error(`Process exited with code ${code} for: ${testCase.name}`));
      }
    });

    // Send input after a short delay to allow initialization
    setTimeout(() => {
      cliProcess.stdin.write(testCase.input + '\n');
    }, 2000);
  });
}

function analyzeResponse(output, testCase) {
  const lowerOutput = output.toLowerCase();
  
  // Check for expected keywords
  const foundKeywords = testCase.expectedKeywords.filter(keyword => 
    lowerOutput.includes(keyword.toLowerCase())
  );
  
  // Check for hardcoded responses that should not appear
  const foundHardcoded = testCase.shouldNotContain.filter(phrase => 
    lowerOutput.includes(phrase.toLowerCase())
  );
  
  const result = {
    testCase: testCase.name,
    success: foundKeywords.length > 0 && foundHardcoded.length === 0,
    foundKeywords,
    missingKeywords: testCase.expectedKeywords.filter(k => !foundKeywords.includes(k)),
    foundHardcoded,
    responseLength: output.length,
    isLLMGenerated: output.length > 100 && !testCase.shouldNotContain.some(phrase => 
      lowerOutput.includes(phrase.toLowerCase())
    )
  };
  
  return result;
}

function printResults(results) {
  console.log('\nğŸ“Š Test Results Summary:\n');
  
  let passed = 0;
  let failed = 0;
  
  results.forEach(result => {
    const status = result.success ? 'âœ… PASS' : 'âŒ FAIL';
    console.log(`${status} ${result.testCase}`);
    
    if (result.success) {
      console.log(`   âœ… Found keywords: ${result.foundKeywords.join(', ')}`);
      console.log(`   âœ… No hardcoded responses detected`);
      console.log(`   âœ… Response length: ${result.responseLength} characters`);
      passed++;
    } else {
      console.log(`   âŒ Missing keywords: ${result.missingKeywords.join(', ')}`);
      if (result.foundHardcoded.length > 0) {
        console.log(`   âŒ Found hardcoded responses: ${result.foundHardcoded.join(', ')}`);
      }
      console.log(`   âŒ Response length: ${result.responseLength} characters`);
      failed++;
    }
    console.log('');
  });
  
  console.log(`ğŸ¯ Overall Results: ${passed} passed, ${failed} failed`);
  
  if (failed === 0) {
    console.log('ğŸ‰ All tests passed! The system is fully LLM-based.');
  } else {
    console.log('âš ï¸  Some tests failed. There may still be hardcoded responses.');
  }
}

async function main() {
  try {
    console.log('ğŸš€ Starting LLM-based system tests...\n');
    
    const results = [];
    
    for (const testCase of testCases) {
      try {
        const result = await runTest(testCase);
        results.push(result);
        
        // Small delay between tests
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        console.log(`âŒ Test failed for ${testCase.name}: ${error.message}`);
        results.push({
          testCase: testCase.name,
          success: false,
          error: error.message
        });
      }
    }
    
    printResults(results);
    
  } catch (error) {
    console.error('âŒ Test suite failed:', error.message);
    process.exit(1);
  }
}

// Run the tests
main().catch(console.error); 